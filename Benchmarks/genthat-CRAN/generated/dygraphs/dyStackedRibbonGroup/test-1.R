library(dygraphs)

function_to_run <- function() {
    . <- structure(list(x = structure(list(attrs = list(axes = list(x = list(pixelsPerLabel = 60), y = list(valueRange = c(0, 
        4085.55))), series = list(line = list(axis = "y", strokePattern = c(7, 3)), ldeaths = list(axis = "y", stepPlot = TRUE), 
        additive = list(axis = "y", plotter = structure("/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var axis = g.attr_(\"axis\", e.setName);\n  var y_bottom = g.toDomYCoord(0, axis == \"y2\" ? 1 : 0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}", 
            class = "JS_EVAL"), group = "additivemdeaths"), mdeaths = list(axis = "y", plotter = structure("/**\n * Bar Chart plotter is adapted from http://dygraphs.com/tests/plotters.html\n */\nfunction stackedBarPlotter(e) {\n  //extracting and reducing the Dygraph.stackPoints_ function\n  stackPoints = function(points, cumulativeYval, seriesExtremes, fillMethod) {\n    var lastXval = null;\n    var prevPoint = null;\n    var nextPoint = null;\n    var nextPointIdx = -1;\n  \n    // Find the next stackable point starting from the given index.\n    var updateNextPoint = function(idx) {\n      // If we've previously found a non-NaN point and haven't gone past it yet,\n      // just use that.\n      if (nextPointIdx >= idx) return;\n  \n      // We haven't found a non-NaN point yet or have moved past it,\n      // look towards the right to find a non-NaN point.\n      for (var j = idx; j < points.length; ++j) {\n        // Clear out a previously-found point (if any) since it's no longer\n        // valid, we shouldn't use it for interpolation anymore.\n        nextPoint = null;\n        if (!isNaN(points[j].yval) && points[j].yval !== null) {\n          nextPointIdx = j;\n          nextPoint = points[j];\n          break;\n        }\n      }\n    };\n  \n    for (var i = 0; i < points.length; ++i) {\n      var point = points[i];\n      var xval = point.xval;\n      if (cumulativeYval[xval] === undefined) {\n        cumulativeYval[xval] = 0;\n      }\n  \n      var actualYval = point.yval;\n      if (isNaN(actualYval) || actualYval === null) {\n        if(fillMethod == 'none') {\n          actualYval = 0;\n        } else {\n          // Interpolate/extend for stacking purposes if possible.\n          updateNextPoint(i);\n          if (prevPoint && nextPoint && fillMethod != 'none') {\n            // Use linear interpolation between prevPoint and nextPoint.\n            actualYval = prevPoint.yval + (nextPoint.yval - prevPoint.yval) *\n                ((xval - prevPoint.xval) / (nextPoint.xval - prevPoint.xval));\n          } else if (prevPoint && fillMethod == 'all') {\n            actualYval = prevPoint.yval;\n          } else if (nextPoint && fillMethod == 'all') {\n            actualYval = nextPoint.yval;\n          } else {\n            actualYval = 0;\n          }\n        }\n      } else {\n        prevPoint = point;\n      }\n  \n      var stackedYval = cumulativeYval[xval];\n      if (lastXval != xval) {\n        // If an x-value is repeated, we ignore the duplicates.\n        stackedYval += actualYval;\n        cumulativeYval[xval] = stackedYval;\n      }\n      lastXval = xval;\n  \n      point.yval_stacked = stackedYval;\n      \n      if (stackedYval > seriesExtremes[1]) {\n        seriesExtremes[1] = stackedYval;\n      }\n      if (stackedYval < seriesExtremes[0]) {\n        seriesExtremes[0] = stackedYval;\n      }\n  \n    }\n  };\n  \n  // BEGIN HEADER BLOCK\n  // This first block can be copied to other plotters to capture the group \n  var g = e.dygraph;\n  \n  var group;\n  var groupIdx = [];\n  var sets = [];\n  var allSets = e.allSeriesPoints;\n  var minIdx = Infinity;\n  var setName = e.setName;\n  var setNames = g.getLabels().slice(1);\n  var groupSetNames = [];\n  var fillColors = [];\n  var strokeColors = g.getColors();\n  // this next one we use further down, but will be populated in a decreasing loop,\n  // so we'll establish the size in this forward loop so it has the structure to accept\n  // later on.\n  var seriesExtremes = [];\n  \n  var currGroup = g.attr_(\"group\", setName);\n  \n  for (var setIdx = 0; setIdx < allSets.length; setIdx++) {\n    // get the name and group of the current setIdx\n    setName = setNames[setIdx];\n    group = g.attr_(\"group\", setName);\n\n    if (group === currGroup) {\n      //save the indv index and the points\n      groupIdx.push(setIdx);\n      sets.push(allSets[setIdx]);\n      groupSetNames.push(setName);\n      fillColors.push(strokeColors[setIdx]);\n     \n      // the aforementioned stuff for later on \n      var tmpExtremes = [];\n      tmpExtremes[0] = Infinity;\n      tmpExtremes[1] = -Infinity;\n      \n      seriesExtremes.push(tmpExtremes);\n      \n      // capturing the min indx helps to ensure we don't render the plotter\n      // multiple times\n      if (setIdx < minIdx) minIdx = setIdx;\n    }\n  }\n  \n  // We'll employ the plotter only on the first of the group\n  if (e.seriesIndex !== minIdx) return;\n  // END HEADER BLOCK\n  \n  var ctx = e.drawingContext;\n  var axis = g.attr_(\"axis\", e.setName);\n  var y_bottom = g.toDomYCoord(0, axis == \"y2\" ? 1 : 0);\n\n  // Find the minimum separation between x-values.\n  // This determines the bar width.\n  var min_sep = Infinity;\n  var points = sets[0];\n  \n  for (var i = 1; i < points.length; i++) {\n    var sep = points[i].canvasx - points[i - 1].canvasx;\n    if (sep < min_sep) min_sep = sep;\n  }\n  var bar_width = Math.floor(2.0 / 3 * min_sep);\n\n  // set up cumulative records\n  var cumulativeYval = [];\n  var packed = g.gatherDatasets_(g.rolledSeries_, null);\n  var extremes = packed.extremes;\n  var seriesName;\n  \n  for (var j = sets.length - 1; j >= 0; j--) {\n    points = sets[j];\n    seriesName = groupSetNames[j]; \n    \n    //  stack the data \n    stackPoints(points, cumulativeYval, seriesExtremes[j],\n          g.getBooleanOption(\"stackedGraphNaNFill\"));\n    \n    extremes[seriesName] = seriesExtremes[j];\n  }\n   \n  // There is currently no way to update the axes height from inside the plotter...\n  // Will have to wait until update can be made to underlying dygraphs lib\n  // Preferring to do issue or pull request to main library on github instead of modifying here\n  // g.computeYAxisRanges_(extremes);\n  // g.layout_.setYAxes(g.axes_);\n  \n  var currSetName;\n  var logscale;\n  var connectSeparated;\n    \n  // Do the actual plotting.\n  for (var j = 0; j < sets.length; j++) {\n    currSetName = groupSetNames[j];\n    connectSeparated = g.getOption('connectSeparatedPoints', currSetName);\n    logscale = g.attributes_.getForSeries(\"logscale\", currSetName);\n    \n    axis = g.axisPropertiesForSeries(currSetName);\n    \n    points = sets[j];\n    \n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      \n      var yval = point.yval;\n      \n      point.y_stacked = DygraphLayout.calcYNormal_(\n          axis, point.yval_stacked, logscale);\n          \n      if (yval !== null && !isNaN(yval)) {\n        yval = point.yval_stacked;\n      }\n      if (yval === null) {\n        yval = NaN;\n        if (!connectSeparated) {\n          point.yval = NaN;\n        }\n      }\n      point.y = DygraphLayout.calcYNormal_(axis, yval, logscale);\n    \n      point.canvasx = g.plotter_.area.w * point.x + g.plotter_.area.x;\n      point.canvasy = g.plotter_.area.h * point.y + g.plotter_.area.y;\n      \n      var center_x = point.canvasx;\n      \n      ctx.fillStyle = fillColors[j];\n      ctx.strokeStyle = fillColors[j];\n    \n      ctx.fillRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    \n      ctx.strokeRect(center_x - bar_width / 2, point.canvasy,\n        bar_width, y_bottom - point.canvasy);\n    }\n  }\n}", 
            class = "JS_EVAL"), group = "additivemdeaths")), labels = c("month", "fdeaths", "line", "ldeaths", "additive", 
        "mdeaths"), legend = "auto", retainDateWindow = FALSE), scale = "monthly", annotations = list(), shadings = list(), 
        events = list(), format = "date", data = list(c("1974-01-01T00:00:00.000Z", "1974-02-01T00:00:00.000Z", "1974-03-01T00:00:00.000Z", 
            "1974-04-01T00:00:00.000Z", "1974-05-01T00:00:00.000Z", "1974-06-01T00:00:00.000Z", "1974-07-01T00:00:00.000Z", 
            "1974-08-01T00:00:00.000Z", "1974-09-01T00:00:00.000Z", "1974-10-01T00:00:00.000Z", "1974-11-01T00:00:00.000Z", 
            "1974-12-01T00:00:00.000Z", "1975-01-01T00:00:00.000Z", "1975-02-01T00:00:00.000Z", "1975-03-01T00:00:00.000Z", 
            "1975-04-01T00:00:00.000Z", "1975-05-01T00:00:00.000Z", "1975-06-01T00:00:00.000Z", "1975-07-01T00:00:00.000Z", 
            "1975-08-01T00:00:00.000Z", "1975-09-01T00:00:00.000Z", "1975-10-01T00:00:00.000Z", "1975-11-01T00:00:00.000Z", 
            "1975-12-01T00:00:00.000Z", "1976-01-01T00:00:00.000Z", "1976-02-01T00:00:00.000Z", "1976-03-01T00:00:00.000Z", 
            "1976-04-01T00:00:00.000Z", "1976-05-01T00:00:00.000Z", "1976-06-01T00:00:00.000Z", "1976-07-01T00:00:00.000Z", 
            "1976-08-01T00:00:00.000Z", "1976-09-01T00:00:00.000Z", "1976-10-01T00:00:00.000Z", "1976-11-01T00:00:00.000Z", 
            "1976-12-01T00:00:00.000Z", "1977-01-01T00:00:00.000Z", "1977-02-01T00:00:00.000Z", "1977-03-01T00:00:00.000Z", 
            "1977-04-01T00:00:00.000Z", "1977-05-01T00:00:00.000Z", "1977-06-01T00:00:00.000Z", "1977-07-01T00:00:00.000Z", 
            "1977-08-01T00:00:00.000Z", "1977-09-01T00:00:00.000Z", "1977-10-01T00:00:00.000Z", "1977-11-01T00:00:00.000Z", 
            "1977-12-01T00:00:00.000Z", "1978-01-01T00:00:00.000Z", "1978-02-01T00:00:00.000Z", "1978-03-01T00:00:00.000Z", 
            "1978-04-01T00:00:00.000Z", "1978-05-01T00:00:00.000Z", "1978-06-01T00:00:00.000Z", "1978-07-01T00:00:00.000Z", 
            "1978-08-01T00:00:00.000Z", "1978-09-01T00:00:00.000Z", "1978-10-01T00:00:00.000Z", "1978-11-01T00:00:00.000Z", 
            "1978-12-01T00:00:00.000Z", "1979-01-01T00:00:00.000Z", "1979-02-01T00:00:00.000Z", "1979-03-01T00:00:00.000Z", 
            "1979-04-01T00:00:00.000Z", "1979-05-01T00:00:00.000Z", "1979-06-01T00:00:00.000Z", "1979-07-01T00:00:00.000Z", 
            "1979-08-01T00:00:00.000Z", "1979-09-01T00:00:00.000Z", "1979-10-01T00:00:00.000Z", "1979-11-01T00:00:00.000Z", 
            "1979-12-01T00:00:00.000Z"), c(901, 689, 827, 677, 522, 406, 441, 393, 387, 582, 578, 666, 830, 752, 785, 664, 
            467, 438, 421, 412, 343, 440, 531, 771, 767, 1141, 896, 532, 447, 420, 376, 330, 357, 445, 546, 764, 862, 660, 
            663, 643, 502, 392, 411, 348, 387, 385, 411, 638, 796, 853, 737, 546, 530, 446, 431, 362, 387, 430, 425, 679, 
            821, 785, 727, 612, 478, 429, 405, 379, 393, 411, 487, 574), c(3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
            3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
            3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
            3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
            3000, 3000, 3000, 3000, 3000, 3000, 3000), c(3035, 2552, 2704, 2554, 2014, 1655, 1721, 1524, 1596, 2074, 2199, 
            2512, 2933, 2889, 2938, 2497, 1870, 1726, 1607, 1545, 1396, 1787, 2076, 2837, 2787, 3891, 3179, 2011, 1636, 1580, 
            1489, 1300, 1356, 1653, 2013, 2823, 3102, 2294, 2385, 2444, 1748, 1554, 1498, 1361, 1346, 1564, 1640, 2293, 2815, 
            3137, 2679, 1969, 1870, 1633, 1529, 1366, 1357, 1570, 1535, 2491, 3084, 2605, 2573, 2143, 1693, 1504, 1461, 1354, 
            1333, 1492, 1781, 1915), c(200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 
            200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 
            200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 
            200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200), c(2134, 1863, 1877, 1877, 1492, 1249, 1280, 1131, 1209, 
            1492, 1621, 1846, 2103, 2137, 2153, 1833, 1403, 1288, 1186, 1133, 1053, 1347, 1545, 2066, 2020, 2750, 2283, 1479, 
            1189, 1160, 1113, 970, 999, 1208, 1467, 2059, 2240, 1634, 1722, 1801, 1246, 1162, 1087, 1013, 959, 1179, 1229, 
            1655, 2019, 2284, 1942, 1423, 1340, 1187, 1098, 1004, 970, 1140, 1110, 1812, 2263, 1820, 1846, 1531, 1215, 1075, 
            1056, 975, 940, 1081, 1294, 1341))), time = structure(c(1974, 1974.08333333333, 1974.16666666667, 1974.25, 1974.33333333333, 
        1974.41666666667, 1974.5, 1974.58333333333, 1974.66666666667, 1974.75, 1974.83333333333, 1974.91666666667, 1975, 
        1975.08333333333, 1975.16666666667, 1975.25, 1975.33333333333, 1975.41666666667, 1975.5, 1975.58333333333, 1975.66666666667, 
        1975.75, 1975.83333333333, 1975.91666666667, 1976, 1976.08333333333, 1976.16666666667, 1976.25, 1976.33333333333, 
        1976.41666666667, 1976.5, 1976.58333333333, 1976.66666666667, 1976.75, 1976.83333333333, 1976.91666666667, 1977, 
        1977.08333333333, 1977.16666666667, 1977.25, 1977.33333333333, 1977.41666666667, 1977.5, 1977.58333333333, 1977.66666666667, 
        1977.75, 1977.83333333333, 1977.91666666667, 1978, 1978.08333333333, 1978.16666666667, 1978.25, 1978.33333333333, 
        1978.41666666667, 1978.5, 1978.58333333333, 1978.66666666667, 1978.75, 1978.83333333333, 1978.91666666667, 1979, 
        1979.08333333333, 1979.16666666667, 1979.25, 1979.33333333333, 1979.41666666667, 1979.5, 1979.58333333333, 1979.66666666667, 
        1979.75, 1979.83333333333, 1979.91666666667), class = "yearmon"), data = list(month = c("1974-01-01T00:00:00.000Z", 
        "1974-02-01T00:00:00.000Z", "1974-03-01T00:00:00.000Z", "1974-04-01T00:00:00.000Z", "1974-05-01T00:00:00.000Z", "1974-06-01T00:00:00.000Z", 
        "1974-07-01T00:00:00.000Z", "1974-08-01T00:00:00.000Z", "1974-09-01T00:00:00.000Z", "1974-10-01T00:00:00.000Z", "1974-11-01T00:00:00.000Z", 
        "1974-12-01T00:00:00.000Z", "1975-01-01T00:00:00.000Z", "1975-02-01T00:00:00.000Z", "1975-03-01T00:00:00.000Z", "1975-04-01T00:00:00.000Z", 
        "1975-05-01T00:00:00.000Z", "1975-06-01T00:00:00.000Z", "1975-07-01T00:00:00.000Z", "1975-08-01T00:00:00.000Z", "1975-09-01T00:00:00.000Z", 
        "1975-10-01T00:00:00.000Z", "1975-11-01T00:00:00.000Z", "1975-12-01T00:00:00.000Z", "1976-01-01T00:00:00.000Z", "1976-02-01T00:00:00.000Z", 
        "1976-03-01T00:00:00.000Z", "1976-04-01T00:00:00.000Z", "1976-05-01T00:00:00.000Z", "1976-06-01T00:00:00.000Z", "1976-07-01T00:00:00.000Z", 
        "1976-08-01T00:00:00.000Z", "1976-09-01T00:00:00.000Z", "1976-10-01T00:00:00.000Z", "1976-11-01T00:00:00.000Z", "1976-12-01T00:00:00.000Z", 
        "1977-01-01T00:00:00.000Z", "1977-02-01T00:00:00.000Z", "1977-03-01T00:00:00.000Z", "1977-04-01T00:00:00.000Z", "1977-05-01T00:00:00.000Z", 
        "1977-06-01T00:00:00.000Z", "1977-07-01T00:00:00.000Z", "1977-08-01T00:00:00.000Z", "1977-09-01T00:00:00.000Z", "1977-10-01T00:00:00.000Z", 
        "1977-11-01T00:00:00.000Z", "1977-12-01T00:00:00.000Z", "1978-01-01T00:00:00.000Z", "1978-02-01T00:00:00.000Z", "1978-03-01T00:00:00.000Z", 
        "1978-04-01T00:00:00.000Z", "1978-05-01T00:00:00.000Z", "1978-06-01T00:00:00.000Z", "1978-07-01T00:00:00.000Z", "1978-08-01T00:00:00.000Z", 
        "1978-09-01T00:00:00.000Z", "1978-10-01T00:00:00.000Z", "1978-11-01T00:00:00.000Z", "1978-12-01T00:00:00.000Z", "1979-01-01T00:00:00.000Z", 
        "1979-02-01T00:00:00.000Z", "1979-03-01T00:00:00.000Z", "1979-04-01T00:00:00.000Z", "1979-05-01T00:00:00.000Z", "1979-06-01T00:00:00.000Z", 
        "1979-07-01T00:00:00.000Z", "1979-08-01T00:00:00.000Z", "1979-09-01T00:00:00.000Z", "1979-10-01T00:00:00.000Z", "1979-11-01T00:00:00.000Z", 
        "1979-12-01T00:00:00.000Z"), ldeaths = c(3035, 2552, 2704, 2554, 2014, 1655, 1721, 1524, 1596, 2074, 2199, 2512, 
        2933, 2889, 2938, 2497, 1870, 1726, 1607, 1545, 1396, 1787, 2076, 2837, 2787, 3891, 3179, 2011, 1636, 1580, 1489, 
        1300, 1356, 1653, 2013, 2823, 3102, 2294, 2385, 2444, 1748, 1554, 1498, 1361, 1346, 1564, 1640, 2293, 2815, 3137, 
        2679, 1969, 1870, 1633, 1529, 1366, 1357, 1570, 1535, 2491, 3084, 2605, 2573, 2143, 1693, 1504, 1461, 1354, 1333, 
        1492, 1781, 1915), fdeaths = c(901, 689, 827, 677, 522, 406, 441, 393, 387, 582, 578, 666, 830, 752, 785, 664, 467, 
        438, 421, 412, 343, 440, 531, 771, 767, 1141, 896, 532, 447, 420, 376, 330, 357, 445, 546, 764, 862, 660, 663, 643, 
        502, 392, 411, 348, 387, 385, 411, 638, 796, 853, 737, 546, 530, 446, 431, 362, 387, 430, 425, 679, 821, 785, 727, 
        612, 478, 429, 405, 379, 393, 411, 487, 574), mdeaths = c(2134, 1863, 1877, 1877, 1492, 1249, 1280, 1131, 1209, 1492, 
        1621, 1846, 2103, 2137, 2153, 1833, 1403, 1288, 1186, 1133, 1053, 1347, 1545, 2066, 2020, 2750, 2283, 1479, 1189, 
        1160, 1113, 970, 999, 1208, 1467, 2059, 2240, 1634, 1722, 1801, 1246, 1162, 1087, 1013, 959, 1179, 1229, 1655, 2019, 
        2284, 1942, 1423, 1340, 1187, 1098, 1004, 970, 1140, 1110, 1812, 2263, 1820, 1846, 1531, 1215, 1075, 1056, 975, 940, 
        1081, 1294, 1341), additive = c(200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 
        200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 
        200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 
        200, 200, 200, 200, 200, 200, 200, 200, 200), line = c(3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
        3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
        3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
        3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 
        3000, 3000, 3000, 3000, 3000)), autoSeries = 4), width = NULL, height = NULL, sizingPolicy = list(defaultWidth = NULL, 
        defaultHeight = NULL, padding = NULL, viewer = list(defaultWidth = NULL, defaultHeight = NULL, padding = 10, fill = TRUE, 
            suppress = FALSE, paneHeight = NULL), browser = list(defaultWidth = NULL, defaultHeight = NULL, padding = NULL, 
            fill = TRUE, external = FALSE), knitr = list(defaultWidth = NULL, defaultHeight = NULL, figure = TRUE)), dependencies = NULL, 
        elementId = NULL, preRenderHook = NULL, jsHooks = list()), class = c("dygraphs", "htmlwidget"), package = "dygraphs")
    dygraphs:::dyStackedRibbonGroup(dygraph = ., name = c("fdeaths", "ldeaths"))
}




